<head>
    <script crossorigin="anonymous" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  
    <!-- Google AdSense Using Machine Learning Code -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-3071098372371409",
            enable_page_level_ads: true
        });
    </script>
    <style>
        pre {
            white-space: pre-wrap;
            white-space: -moz-pre-wrap;
            white-space: -pre-wrap;
            white-space: -o-pre-wrap;
            word-wrap: break-word;
        }

        .customLink {
            background-color: #4CAF50;
            border: none;
            color: white !important;
            padding: 8px 13px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
        }

        .customLink:hover {
            text-decoration: none;
        }

        div.code-block-decoration.footer {
            display: none;
        }
    </style>
</head>

<a class="customLink" href="http://survival8.blogspot.com/2024/04/index-for-job-interviews-preparation.html" target="_blank">Index For Job Interviews Preparation</a>

<pre>
<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvAhnmhcKj15JFvdmN9TkAmn87UrrDKGSjNCCCYgqLQU_pTgueunLCf79RLJ_lEF3VG56znWTFRASAVSXyLlSUHFnWxErIvjQyxdt8dqwvl2H-2jNNcKAyFVlqyMRWnmV_8zAFNlu0Kdy8ah7wccxmMpnSqX5bXx_gsLkUC_NhjlF9NVw2CSqModhjwReB/s601/knn.png" style="display: block; padding: 1em 0; text-align: center; "><img alt="" border="0" width="600" data-original-height="402" data-original-width="601" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvAhnmhcKj15JFvdmN9TkAmn87UrrDKGSjNCCCYgqLQU_pTgueunLCf79RLJ_lEF3VG56znWTFRASAVSXyLlSUHFnWxErIvjQyxdt8dqwvl2H-2jNNcKAyFVlqyMRWnmV_8zAFNlu0Kdy8ah7wccxmMpnSqX5bXx_gsLkUC_NhjlF9NVw2CSqModhjwReB/s600/knn.png"/></a></div>

<h2>Please share 10 MCQs for kNN algorithm.</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><ol data-sourcepos="1:1-59:60">
<li data-sourcepos="1:1-6:0">
<p data-sourcepos="1:4-5:76">Which of the following statements are TRUE about the k-Nearest Neighbors (kNN) algorithm?
a) kNN is a parametric learning algorithm.
b) kNN requires training data to make predictions. <strong>(b)</strong>
c) kNN learns a decision boundary to classify data points.
d) kNN is computationally expensive for high-dimensional data. <strong>(d)</strong></p>
</li>
<li data-sourcepos="7:1-12:0">
<p data-sourcepos="7:4-11:56">In kNN, the value of k represents:
a) The number of features used in the model.
b) The number of nearest neighbors considered for prediction.  <strong>(b)</strong>
c) The maximum distance allowed between neighbors.
d) The number of clusters to be formed in the data.</p>
</li>
<li data-sourcepos="13:1-18:0">
<p data-sourcepos="13:4-17:24">Which of the following distance metrics is commonly used in kNN for numerical data?
a) Manhattan distance
b) Euclidean distance  <strong>(b)</strong>
c) Cosine similarity
d) All of the above</p>
</li>
<li data-sourcepos="19:1-24:0">
<p data-sourcepos="19:4-23:48">kNN is more effective for:
a) Linearly separable data
b) Non-linearly separable data  <strong>(b)</strong>
c) Data with a very high number of dimensions
d) Data with a very small number of samples</p>
</li>
<li data-sourcepos="25:1-30:0">
<p data-sourcepos="25:4-29:24">What is a major disadvantage of kNN?
a) It can be sensitive to the choice of the distance metric.
b) It can suffer from the curse of dimensionality.  <strong>(b)</strong>
c) It requires a significant amount of training data for good performance.
d) All of the above</p>
</li>
<li data-sourcepos="31:1-36:0">
<p data-sourcepos="31:4-35:24">Which technique can be used to improve the performance of kNN on high-dimensional data?
a) Feature scaling
b) Feature selection  <strong>(b)</strong>
c) Increasing the value of k
d) All of the above</p>
</li>
<li data-sourcepos="37:1-42:0">
<p data-sourcepos="37:4-41:51">kNN can be used for both:
a) Classification tasks only
b) Regression tasks only
c) Both classification and regression tasks  <strong>(c)</strong>
d) Neither classification nor regression tasks</p>
</li>
<li data-sourcepos="43:1-48:0">
<p data-sourcepos="43:4-47:42">kNN is a:
a) Lazy learning algorithm  <strong>(a)</strong>
b) Eager learning algorithm
c) Unsupervised learning algorithm
d) Semi-supervised learning algorithm</p>
</li>
<li data-sourcepos="49:1-54:0">
<p data-sourcepos="49:4-53:24">K-Means clustering and kNN share some similarities. How are they different in their approach?
a) K-Means assigns data points to existing clusters, while kNN predicts labels based on neighbors.  <strong>(a)</strong>
b) K-Means uses labeled data, while kNN does not require labeled data for prediction.
c) K-Means is a parametric algorithm, while kNN is non-parametric.
d) All of the above</p>
</li>
<li data-sourcepos="55:1-59:60">
<p data-sourcepos="55:5-59:60">When evaluating the performance of a kNN model, which metric is most appropriate?
a) Accuracy (for classification)
b) Precision and Recall (for classification)
c) F1-score (for classification)  <strong>(c)</strong>
d) All of the above (depending on the specific problem)</p>
</li>
</ol></div>
</pre>

<h2>Please share 10 scenario based complex questions for kNN</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><h2 data-sourcepos="1:1-1:57">10 Scenario-Based Complex Questions for kNN Algorithm:</h2><ol data-sourcepos="3:1-22:0">
<li data-sourcepos="3:1-4:0">
<p data-sourcepos="3:4-3:389"><strong>Image Classification with Imbalanced Classes:</strong> You're building a kNN model to classify images into different types of animals (cats, dogs, birds). However, the dataset is imbalanced, with significantly more cat images than bird images. How can you adjust the kNN algorithm or data pre-processing to handle this imbalance and ensure fair classification performance across all classes?</p>
</li>
<li data-sourcepos="5:1-6:0">
<p data-sourcepos="5:4-5:369"><strong>Real-Time Fraud Detection:</strong> Imagine a system that monitors financial transactions for fraudulent activity using kNN. New transactions arrive continuously. How can you adapt kNN for real-time processing while maintaining accuracy? Consider aspects like efficiency, handling concept drift (changes in fraud patterns), and incorporating new data points effectively.</p>
</li>
<li data-sourcepos="7:1-8:0">
<p data-sourcepos="7:4-7:262"><strong>Missing Value Imputation with kNN:</strong> You're using kNN for customer segmentation, but some customer data points have missing values for income and age. How can you modify kNN to handle missing values and still achieve effective customer group classification?</p>
</li>
<li data-sourcepos="9:1-10:0">
<p data-sourcepos="9:4-9:325"><strong>High-Dimensional Text Data Clustering:</strong> You want to cluster news articles by topic using kNN. Text data can be high-dimensional due to a large vocabulary.  What pre-processing techniques can you apply to make kNN work efficiently for text clustering? How can you choose an appropriate distance metric for this scenario?</p>
</li>
<li data-sourcepos="11:1-12:0">
<p data-sourcepos="11:4-11:322"><strong>Combining kNN with Feature Engineering:</strong> You're building a kNN model to predict stock prices. While raw historical prices can be used as features, could feature engineering techniques like calculating moving averages or volatility indicators improve the performance of kNN for stock price prediction? Why or why not?</p>
</li>
<li data-sourcepos="13:1-14:0">
<p data-sourcepos="13:4-13:287"><strong>kNN for Anomaly Detection:</strong>  Anomaly detection involves identifying data points that deviate significantly from the norm. How can you adapt kNN to identify anomalies in sensor data streams, considering factors like real-time processing and flagging potential outliers effectively?</p>
</li>
<li data-sourcepos="15:1-16:0">
<p data-sourcepos="15:4-15:351"><strong>Choosing k for Imbalanced Time Series Data:</strong> You're using kNN to predict short-term stock price movements using historical time series data. The data might have seasonal trends and imbalanced class distribution (more upward movements than downward). How can you determine the optimal value of k for kNN in this time series forecasting scenario?</p>
</li>
<li data-sourcepos="17:1-18:0">
<p data-sourcepos="17:4-17:289"><strong>kNN vs. Decision Trees for Credit Risk Assessment:</strong>  A bank is considering kNN and decision trees for credit risk assessment. Both can handle numerical and categorical data. What are some factors to consider when choosing between kNN and decision trees for this specific application?</p>
</li>
<li data-sourcepos="19:1-20:0">
<p data-sourcepos="19:4-19:325"><strong>Explainability and Interpretability of kNN Models:</strong>  kNN models can be less interpretable compared to some other algorithms. How can you explain the predictions made by a kNN model for loan approval or customer churn prediction? What techniques can be used to gain insights into the factors influencing kNN's decisions?</p>
</li>
<li data-sourcepos="21:1-22:0">
<p data-sourcepos="21:5-21:447"><strong>kNN for Imbalanced Recommender Systems:</strong>  A recommender system uses kNN to suggest products to users based on their past purchases. However, user purchase history might be sparse, leading to an imbalanced dataset where some products are purchased much more frequently than others. How can you address this class imbalance and ensure the recommender system suggests relevant products for all users, even those with limited purchase history?</p>
</li>
</ol><p data-sourcepos="23:1-23:205">These scenario-based questions encourage you to think critically about applying kNN in various situations, considering data characteristics, limitations, and potential adjustments for optimal performance.</p></div>

<pre><h2>Solve this:
Image Classification with Imbalanced Classes: You're building a kNN model to classify images into different types of animals (cats, dogs, birds). However, the dataset is imbalanced, with significantly more cat images than bird images. How can you adjust the kNN algorithm or data pre-processing to handle this imbalance and ensure fair classification performance across all classes?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:88">Here are some strategies to address imbalanced classes in image classification with kNN:</p><p data-sourcepos="3:1-3:35"><strong>Data Pre-processing Techniques:</strong></p><ol data-sourcepos="5:1-10:0">
<li data-sourcepos="5:1-6:0">
<p data-sourcepos="5:4-5:280"><strong>Oversampling:</strong> Replicate images from the minority class (birds) to create a more balanced dataset. Techniques like SMOTE (Synthetic Minority Oversampling Technique) can be used to generate synthetic variations of minority class images while preserving their characteristics.</p>
</li>
<li data-sourcepos="7:1-8:0">
<p data-sourcepos="7:4-7:179"><strong>Undersampling:</strong> Randomly remove images from the majority class (cats) to match the size of the minority class. This reduces training data but might lead to information loss.</p>
</li>
<li data-sourcepos="9:1-10:0">
<p data-sourcepos="9:4-9:238"><strong>Cost-Sensitive Learning:</strong> Assign higher weights to misclassified instances from the minority class during training. This penalizes the model more for mistakes on birds, encouraging it to focus on learning their features effectively.</p>
</li>
</ol><p data-sourcepos="11:1-11:30"><strong>kNN Algorithm Adjustments:</strong></p><ol data-sourcepos="13:1-16:0">
<li data-sourcepos="13:1-14:0">
<p data-sourcepos="13:4-13:258"><strong>k-Nearest Neighbors Weighted by Class:</strong> Assign weights to neighboring data points based on their class labels. Neighbors from the minority class (birds) can be given higher weights during voting, increasing their influence on the final classification.</p>
</li>
<li data-sourcepos="15:1-16:0">
<p data-sourcepos="15:4-15:252"><strong>Distance Metrics for Imbalanced Data:</strong> Consider using distance metrics that are less sensitive to outliers, such as the Mahalanobis distance. This metric takes into account the class distribution and can be more effective in imbalanced scenarios.</p>
</li>
</ol><p data-sourcepos="17:1-17:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="19:1-22:0">
<li data-sourcepos="19:1-19:151"><strong>Hybrid Approach:</strong> Combine data pre-processing techniques like oversampling with kNN modifications like weighted voting for a more robust solution.</li>
<li data-sourcepos="20:1-22:0"><strong>Evaluation Metrics:</strong>  For imbalanced datasets, relying solely on accuracy might be misleading. Consider using metrics like F1-score, which considers both precision and recall, to evaluate the model's performance on the minority class (birds).</li>
</ul><p data-sourcepos="23:1-23:253">By implementing these strategies, you can mitigate the impact of imbalanced classes and ensure your kNN model performs well in classifying all animal categories (cats, dogs, and birds) with reasonable accuracy, even for the under-represented bird class.</p></div>

<h2>Can you share code to demonstrate "Distance Metrics for Imbalanced Data" such as Mahalanobis distance for imbalanced dataset?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:167">Here's an example implementation using Python demonstrating how to incorporate Mahalanobis distance into kNN for an imbalanced dataset (assuming scikit-learn library):</p><code-block _nghost-ng-c2652366121="" ng-version="0.0.0-PLACEHOLDER"><!----><!----><!----><!----><div _ngcontent-ng-c2652366121="" class="code-block ng-star-inserted"><div _ngcontent-ng-c2652366121="" class="code-block-decoration header gmat-subtitle-1 ng-star-inserted"><span _ngcontent-ng-c2652366121="">Python</span></div><!----><div _ngcontent-ng-c2652366121="" class="code-block-internal-container"><pre _ngcontent-ng-c2652366121=""><code _ngcontent-ng-c2652366121="" role="text" data-test-id="code-content" class="code-container" data-sourcepos="3:1-55:56"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> pairwise_distances
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MahalanobisKNN</span>(<span class="hljs-params">KNeighborsClassifier</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n_neighbors, metric=<span class="hljs-string">'euclidean'</span></span>):</span>
    <span class="hljs-built_in">super</span>().__init__(n_neighbors=n_neighbors, metric=metric)
    self.mean_vectors = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Stores class mean vectors</span>
    self.cov_matrices = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Stores class covariance matrices</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y</span>):</span>
    <span class="hljs-comment"># Fit the base KNN classifier</span>
    <span class="hljs-built_in">super</span>().fit(X, y)
    self._calculate_class_stats(X, y)
    <span class="hljs-keyword">return</span> self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_calculate_class_stats</span>(<span class="hljs-params">self, X, y</span>):</span>
    <span class="hljs-comment"># Calculate mean vector and covariance matrix for each class</span>
    self.mean_vectors = {}
    self.cov_matrices = {}
    classes = np.unique(y)
    <span class="hljs-keyword">for</span> class_label <span class="hljs-keyword">in</span> classes:
        class_indices = np.where(y == class_label)[<span class="hljs-number">0</span>]
        class_data = X[class_indices]
        self.mean_vectors[class_label] = np.mean(class_data, axis=<span class="hljs-number">0</span>)
        self.cov_matrices[class_label] = np.cov(class_data.T)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, X</span>):</span>
    <span class="hljs-comment"># Calculate Mahalanobis distances for each data point</span>
    distances = np.zeros((X.shape[<span class="hljs-number">0</span>], <span class="hljs-built_in">len</span>(self.classes_)))
    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(X):
        <span class="hljs-keyword">for</span> class_label <span class="hljs-keyword">in</span> self.classes_:
        mean_vector = self.mean_vectors[class_label]
        cov_matrix = self.cov_matrices[class_label]
        <span class="hljs-comment"># Invert covariance matrix (assuming positive definite)</span>
        inv_cov = np.linalg.inv(cov_matrix)
        mahalanobis_dist = np.sqrt(np.dot(np.dot((x - mean_vector).T, inv_cov), (x - mean_vector)))
        distances[i, self.classes_ == class_label] = mahalanobis_dist
    <span class="hljs-comment"># Find nearest neighbors based on Mahalanobis distances</span>
    neighbors_idx = np.argsort(distances, axis=<span class="hljs-number">1</span>)[:, :self.n_neighbors]
    <span class="hljs-comment"># Use majority vote among neighbors to predict class label</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().predict(X[neighbors_idx])

<span class="hljs-comment"># Example usage (assuming separate training and test data)</span>
X_train, X_test, y_train, y_test = ...  <span class="hljs-comment"># Load imbalanced training and test data</span>
knn_mahalanobis = MahalanobisKNN(n_neighbors=<span class="hljs-number">5</span>)
knn_mahalanobis.fit(X_train, y_train)
y_pred = knn_mahalanobis.predict(X_test)

<span class="hljs-comment"># Evaluate model performance using metrics like F1-score</span>
</code></pre><!----><!----><!----></div><div _ngcontent-ng-c2652366121="" hide-from-message-actions="" class="code-block-decoration footer gmat-overline hide-from-message-actions ng-star-inserted"><div _ngcontent-ng-c2652366121=""><span _ngcontent-ng-c2652366121=""> Use code <a _ngcontent-ng-c2652366121="" href="/faq#coding" target="_blank" rel="noopener noreferrer" aria-label="with caution (opens in a new window)" class="disclaimer-suffix">with caution.</a></span></div><div _ngcontent-ng-c2652366121="" class="buttons"><!----><!----><!----><!----><!----><!----><button _ngcontent-ng-c2652366121="" aria-label="Copy code" mat-icon-button="" mattooltip="Copy code" class="mat-mdc-tooltip-trigger copy-button mdc-icon-button mat-mdc-icon-button gmat-mdc-button-with-prefix mat-unthemed mat-mdc-button-base gmat-mdc-button" mat-ripple-loader-uninitialized="" mat-ripple-loader-class-name="mat-mdc-button-ripple" mat-ripple-loader-centered="" jslog="179062;track:generic_click,impression;BardVeMetadataKey:[[&quot;r_1514db2a5172662b&quot;,&quot;c_e48fbd92ef0bdbc5&quot;,null,&quot;rc_1dae8afa4042d99d&quot;,null,null,&quot;en&quot;,null,1,null,null,1,0]];mutable:true"><span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span><mat-icon _ngcontent-ng-c2652366121="" role="img" class="mat-icon notranslate google-symbols mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">content_copy</mat-icon><span class="mat-mdc-focus-indicator"></span><span class="mat-mdc-button-touch-target"></span></button><!----></div></div><!----></div><!----></code-block><p data-sourcepos="57:1-57:16"><strong>Explanation:</strong></p><ol data-sourcepos="59:1-64:0">
<li data-sourcepos="59:1-59:121">This code defines a custom <code>MahalanobisKNN</code> class that inherits from the <code>KNeighborsClassifier</code> class in scikit-learn.</li>
<li data-sourcepos="60:1-60:97">It overrides the <code>fit</code> and <code>predict</code> methods to incorporate Mahalanobis distance calculations.</li>
<li data-sourcepos="61:1-61:141">During <code>fit</code>, the class calculates the mean vector and covariance matrix for each class in the training data using <code>np.mean</code> and <code>np.cov</code>.</li>
<li data-sourcepos="62:1-62:192">In <code>predict</code>, it iterates through each data point in the test data and calculates the Mahalanobis distance to the mean vector of each class, considering the corresponding covariance matrix.</li>
<li data-sourcepos="63:1-64:0">It identifies the k-nearest neighbors based on the Mahalanobis distances and predicts the class label using majority vote among these neighbors, similar to the standard KNN approach.</li>
</ol><p data-sourcepos="65:1-65:9"><strong>Note:</strong></p><ul data-sourcepos="67:1-68:150">
<li data-sourcepos="67:1-67:190">This example assumes the covariance matrices are positive definite, allowing for inversion. In real-world scenarios, you might need to handle cases where the covariance matrix is singular.</li>
<li data-sourcepos="68:1-68:150">Mahalanobis distance calculation can be computationally expensive for high-dimensional data. Consider dimensionality reduction techniques if needed.</li>
</ul></div>

<h2>Can you share code example to demonstrate "k-Nearest Neighbors Weighted by Class"?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:145">Here's an example code implementation using Python demonstrating k-Nearest Neighbors (kNN) with class weights for imbalanced data classification:</p><code-block _nghost-ng-c2652366121="" ng-version="0.0.0-PLACEHOLDER"><!----><!----><!----><!----><div _ngcontent-ng-c2652366121="" class="code-block ng-star-inserted"><div _ngcontent-ng-c2652366121="" class="code-block-decoration header gmat-subtitle-1 ng-star-inserted"><span _ngcontent-ng-c2652366121="">Python</span></div><!----><div _ngcontent-ng-c2652366121="" class="code-block-internal-container"><pre _ngcontent-ng-c2652366121=""><code _ngcontent-ng-c2652366121="" role="text" data-test-id="code-content" class="code-container" data-sourcepos="3:1-28:56"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.utils.class_weight <span class="hljs-keyword">import</span> compute_class_weight


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedKNN</span>(<span class="hljs-params">KNeighborsClassifier</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n_neighbors, metric=<span class="hljs-string">'euclidean'</span></span>):</span>
    <span class="hljs-built_in">super</span>().__init__(n_neighbors=n_neighbors, metric=metric)
    self.class_weights = <span class="hljs-literal">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y</span>):</span>
    <span class="hljs-comment"># Calculate class weights using class_weight library function</span>
    self.class_weights = compute_class_weight(<span class="hljs-string">'balanced'</span>, np.unique(y), y)
    <span class="hljs-comment"># Fit the base KNN classifier with class weights</span>
    <span class="hljs-built_in">super</span>().fit(X, y, sample_weight=self.class_weights[y])
    <span class="hljs-keyword">return</span> self


<span class="hljs-comment"># Example usage (assuming separate training and test data)</span>
X_train, X_test, y_train, y_test = ...  <span class="hljs-comment"># Load imbalanced training and test data</span>
knn_weighted = WeightedKNN(n_neighbors=<span class="hljs-number">5</span>)
knn_weighted.fit(X_train, y_train)
y_pred = knn_weighted.predict(X_test)

<span class="hljs-comment"># Evaluate model performance using metrics like F1-score</span>
</code></pre><!----><!----><!----></div><div _ngcontent-ng-c2652366121="" hide-from-message-actions="" class="code-block-decoration footer gmat-overline hide-from-message-actions ng-star-inserted"><div _ngcontent-ng-c2652366121=""><span _ngcontent-ng-c2652366121=""> Use code <a _ngcontent-ng-c2652366121="" href="/faq#coding" target="_blank" rel="noopener noreferrer" aria-label="with caution (opens in a new window)" class="disclaimer-suffix">with caution.</a></span></div><div _ngcontent-ng-c2652366121="" class="buttons"><!----><!----><!----><!----><!----><!----><button _ngcontent-ng-c2652366121="" aria-label="Copy code" mat-icon-button="" mattooltip="Copy code" class="mat-mdc-tooltip-trigger copy-button mdc-icon-button mat-mdc-icon-button gmat-mdc-button-with-prefix mat-unthemed mat-mdc-button-base gmat-mdc-button" mat-ripple-loader-uninitialized="" mat-ripple-loader-class-name="mat-mdc-button-ripple" mat-ripple-loader-centered="" jslog="179062;track:generic_click,impression;BardVeMetadataKey:[[&quot;r_b0dc5858a8c575f6&quot;,&quot;c_e48fbd92ef0bdbc5&quot;,null,&quot;rc_6977cf5392e0d697&quot;,null,null,&quot;en&quot;,null,1,null,null,1,0]];mutable:true"><span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span><mat-icon _ngcontent-ng-c2652366121="" role="img" class="mat-icon notranslate google-symbols mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">content_copy</mat-icon><span class="mat-mdc-focus-indicator"></span><span class="mat-mdc-button-touch-target"></span></button><!----></div></div><!----></div><!----></code-block><p data-sourcepos="30:1-30:16"><strong>Explanation:</strong></p><ol data-sourcepos="32:1-36:0">
<li data-sourcepos="32:1-32:118">This code defines a custom <code>WeightedKNN</code> class that inherits from the <code>KNeighborsClassifier</code> class in scikit-learn.</li>
<li data-sourcepos="33:1-33:78">It overrides the <code>fit</code> method to incorporate class weights during training.</li>
<li data-sourcepos="34:1-34:251">The code utilizes the <code>compute_class_weight</code> function from <code>sklearn.utils.class_weight</code> to calculate balanced class weights based on the class distribution in the training data (y). This function assigns higher weights to under-represented classes.</li>
<li data-sourcepos="35:1-36:0">During <code>fit</code>, the class weights are assigned as <code>sample_weight</code> to the base KNN classifier. This tells the kNN algorithm to give higher importance to training instances from minority classes during the learning process.</li>
</ol><p data-sourcepos="37:1-37:13"><strong>Benefits:</strong></p><ul data-sourcepos="39:1-40:0">
<li data-sourcepos="39:1-40:0">This approach focuses more on learning the characteristics of the minority class, leading to potentially better classification performance for those classes in imbalanced datasets.</li>
</ul><p data-sourcepos="41:1-41:9"><strong>Note:</strong></p><ul data-sourcepos="43:1-43:252">
<li data-sourcepos="43:1-43:252">Choosing the appropriate weighting scheme can impact the model's behavior. Experiment with different weighting techniques like 'balanced' or 'inverse_freq' offered by the <code>compute_class_weight</code> function to find the best fit for your specific dataset.</li>
</ul></div>

<h2>Can you share code for "Cost-Sensitive Learning" for kNN?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:98">Here's an example code implementation using Python demonstrating cost-sensitive learning with kNN:</p><code-block _nghost-ng-c2652366121="" ng-version="0.0.0-PLACEHOLDER"><!----><!----><!----><!----><div _ngcontent-ng-c2652366121="" class="code-block ng-star-inserted"><div _ngcontent-ng-c2652366121="" class="code-block-decoration header gmat-subtitle-1 ng-star-inserted"><span _ngcontent-ng-c2652366121="">Python</span></div><!----><div _ngcontent-ng-c2652366121="" class="code-block-internal-container"><pre _ngcontent-ng-c2652366121=""><code _ngcontent-ng-c2652366121="" role="text" data-test-id="code-content" class="code-container" data-sourcepos="3:1-42:54"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CostSensitiveKNN</span>(<span class="hljs-params">KNeighborsClassifier</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n_neighbors, metric=<span class="hljs-string">'euclidean'</span>, cost_matrix=<span class="hljs-literal">None</span></span>):</span>
    <span class="hljs-built_in">super</span>().__init__(n_neighbors=n_neighbors, metric=metric)
    self.cost_matrix = cost_matrix  <span class="hljs-comment"># Stores cost matrix for misclassification</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, X</span>):</span>
    <span class="hljs-comment"># Get neighbors and their labels</span>
    neighbors_idx = <span class="hljs-built_in">super</span>().kneighbors(X, return_distance=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]
    neighbors_labels = self.classes_[neighbors_idx]

    <span class="hljs-comment"># Calculate total cost for each prediction class</span>
    costs = np.zeros((X.shape[<span class="hljs-number">0</span>], <span class="hljs-built_in">len</span>(self.classes_)))
    <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(X):
        <span class="hljs-keyword">for</span> j, neighbor_label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(neighbors_labels[i]):
        costs[i, self.classes_ == neighbor_label] += self.cost_matrix[self.classes_[i], neighbor_label]

    <span class="hljs-comment"># Predict class with minimum total cost</span>
    <span class="hljs-keyword">return</span> self.classes_[np.argmin(costs, axis=<span class="hljs-number">1</span>)]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_cost_matrix</span>(<span class="hljs-params">self, cost_matrix</span>):</span>
    self.cost_matrix = cost_matrix


<span class="hljs-comment"># Example usage (assuming separate training and test data)</span>
X_train, X_test, y_train, y_test = ...  <span class="hljs-comment"># Load training and test data</span>
cost_matrix = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">10</span>],  <span class="hljs-comment"># Cost of misclassifying class 1 as 0</span>
                        [<span class="hljs-number">5</span>, <span class="hljs-number">0</span>]])  <span class="hljs-comment"># Cost of misclassifying class 0 as 1</span>

knn_cost_sensitive = CostSensitiveKNN(n_neighbors=<span class="hljs-number">5</span>)
knn_cost_sensitive.set_cost_matrix(cost_matrix)
knn_cost_sensitive.fit(X_train, y_train)
y_pred = knn_cost_sensitive.predict(X_test)

<span class="hljs-comment"># Evaluate model performance using appropriate metrics</span>
</code></pre><!----><!----><!----></div><div _ngcontent-ng-c2652366121="" hide-from-message-actions="" class="code-block-decoration footer gmat-overline hide-from-message-actions ng-star-inserted"><div _ngcontent-ng-c2652366121=""><span _ngcontent-ng-c2652366121=""> Use code <a _ngcontent-ng-c2652366121="" href="/faq#coding" target="_blank" rel="noopener noreferrer" aria-label="with caution (opens in a new window)" class="disclaimer-suffix">with caution.</a></span></div><div _ngcontent-ng-c2652366121="" class="buttons"><!----><!----><!----><!----><!----><!----><button _ngcontent-ng-c2652366121="" aria-label="Copy code" mat-icon-button="" mattooltip="Copy code" class="mat-mdc-tooltip-trigger copy-button mdc-icon-button mat-mdc-icon-button gmat-mdc-button-with-prefix mat-unthemed mat-mdc-button-base gmat-mdc-button" mat-ripple-loader-uninitialized="" mat-ripple-loader-class-name="mat-mdc-button-ripple" mat-ripple-loader-centered="" jslog="179062;track:generic_click,impression;BardVeMetadataKey:[[&quot;r_bcdee42a0d27e7e1&quot;,&quot;c_e48fbd92ef0bdbc5&quot;,null,&quot;rc_7a1c4f15834ac5f5&quot;,null,null,&quot;en&quot;,null,1,null,null,1,0]];mutable:true"><span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span><mat-icon _ngcontent-ng-c2652366121="" role="img" class="mat-icon notranslate google-symbols mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">content_copy</mat-icon><span class="mat-mdc-focus-indicator"></span><span class="mat-mdc-button-touch-target"></span></button><!----></div></div><!----></div><!----></code-block><p data-sourcepos="44:1-44:16"><strong>Explanation:</strong></p><ol data-sourcepos="46:1-53:0">
<li data-sourcepos="46:1-46:123">This code defines a custom <code>CostSensitiveKNN</code> class that inherits from the <code>KNeighborsClassifier</code> class in scikit-learn.</li>
<li data-sourcepos="47:1-47:78">It overrides the <code>predict</code> method to incorporate cost-sensitive prediction.</li>
<li data-sourcepos="48:1-48:148">The class takes a <code>cost_matrix</code> as input during initialization. This matrix defines the cost associated with misclassifying one class as another.</li>
<li data-sourcepos="49:1-49:134">During <code>predict</code>, the code retrieves the k-nearest neighbors for each data point in the test data using the base KNN functionality.</li>
<li data-sourcepos="50:1-50:74">It iterates through the neighbors and their labels for each data point.</li>
<li data-sourcepos="51:1-51:143">It calculates the total cost associated with predicting each possible class label by looking up the corresponding values in the cost matrix.</li>
<li data-sourcepos="52:1-53:0">Finally, it predicts the class label with the minimum total cost among all neighbors.</li>
</ol><p data-sourcepos="54:1-54:13"><strong>Benefits:</strong></p><ul data-sourcepos="56:1-57:0">
<li data-sourcepos="56:1-57:0">This approach prioritizes minimizing the overall cost of misclassification based on the provided cost matrix.</li>
</ul><p data-sourcepos="58:1-58:9"><strong>Note:</strong></p><ul data-sourcepos="60:1-61:215">
<li data-sourcepos="60:1-60:135">Defining an appropriate cost matrix depends on the specific problem and the relative importance of different misclassification types.</li>
<li data-sourcepos="61:1-61:215">This example assumes a square cost matrix where the cost of misclassifying class i as j is the same as the cost of misclassifying class j as i. You might need to modify the code to handle asymmetric cost matrices.</li>
</ul></div>

<h2>Solve this:
Real-Time Fraud Detection: Imagine a system that monitors financial transactions for fraudulent activity using kNN. New transactions arrive continuously. How can you adapt kNN for real-time processing while maintaining accuracy? Consider aspects like efficiency, handling concept drift (changes in fraud patterns), and incorporating new data points effectively.</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:122">Here are some strategies to adapt kNN for real-time fraud detection in a constantly evolving financial transaction stream:</p><p data-sourcepos="3:1-3:40"><strong>Efficiency for Real-Time Processing:</strong></p><ul data-sourcepos="5:1-8:0">
<li data-sourcepos="5:1-5:277"><strong>Limited Neighborhood Search:</strong>  Instead of searching through the entire dataset for neighbors, consider techniques like ball trees or kd-trees for efficient neighbor search. These data structures allow faster identification of the k-nearest neighbors for a new transaction.</li>
<li data-sourcepos="6:1-6:254"><strong>Approximate Nearest Neighbors (ANN):</strong> Utilize approximate nearest neighbor algorithms to find "good enough" neighbors instead of the exact ones. This can significantly reduce processing time while maintaining acceptable accuracy for fraud detection.</li>
<li data-sourcepos="7:1-8:0"><strong>Reduce Feature Dimensionality:</strong> Analyze the transaction data and identify the most relevant features for fraud detection. By using a smaller feature set, kNN calculations become faster. Feature selection techniques like LASSO regression or chi-square tests can be helpful.</li>
</ul><p data-sourcepos="9:1-9:55"><strong>Handling Concept Drift (Changes in Fraud Patterns):</strong></p><ul data-sourcepos="11:1-14:0">
<li data-sourcepos="11:1-11:237"><strong>Sliding Window Approach:</strong> Maintain a window of recent transactions used for kNN classification. As new transactions arrive, the oldest ones are discarded from the window, keeping the model focused on the most recent fraud patterns.</li>
<li data-sourcepos="12:1-12:321"><strong>Adaptive k Value:</strong> Implement a mechanism to adjust the k value dynamically based on the confidence of predictions. For highly suspicious transactions, a smaller k value (focusing on the closest neighbors) might be appropriate. Conversely, for less suspicious cases, a larger k value can be used for broader context.</li>
<li data-sourcepos="13:1-14:0"><strong>Online Learning Algorithms:</strong> Explore online learning algorithms like incremental kNN or online variants of decision trees that can update the model continuously with new data points, adapting to evolving fraud patterns.</li>
</ul><p data-sourcepos="15:1-15:46"><strong>Incorporating New Data Points Effectively:</strong></p><ul data-sourcepos="17:1-19:0">
<li data-sourcepos="17:1-17:335"><strong>Online Updates:</strong> Implement a strategy to update the model with new transaction data points without retraining the entire kNN model from scratch. This could involve techniques like adding new data points to the existing data structure (e.g., ball tree) or updating the distance metric to account for the changing data distribution.</li>
<li data-sourcepos="18:1-19:0"><strong>Periodic Retraining:</strong> Schedule periodic retraining of the kNN model at regular intervals or when significant changes in fraud patterns are detected. This ensures the model stays current with the evolving landscape of fraudulent activities.</li>
</ul><p data-sourcepos="20:1-20:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="22:1-24:0">
<li data-sourcepos="22:1-22:258"><strong>Cost-Sensitive Learning:</strong>  Consider incorporating cost-sensitive learning into kNN. This approach assigns higher weights to misclassifying fraudulent transactions, as the cost of missing a fraudulent case might be more significant than a false positive.</li>
<li data-sourcepos="23:1-24:0"><strong>Alerting System:</strong>  Design an alerting system based on the kNN prediction confidence score. Transactions exceeding a certain confidence threshold for fraud can be flagged for further investigation.</li>
</ul><p data-sourcepos="25:1-25:202">By implementing these strategies, you can adapt kNN for real-time fraud detection in a way that balances efficiency, adaptability, and accuracy in the face of constantly changing fraudulent activities.</p></div>

<h2>Solve this:
Missing Value Imputation with kNN: You're using kNN for customer segmentation, but some customer data points have missing values for income and age. How can you modify kNN to handle missing values and still achieve effective customer group classification?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:92">Here are some strategies to modify kNN for handling missing values in customer segmentation:</p><p data-sourcepos="3:1-3:29"><strong>Preprocessing Techniques:</strong></p><ol data-sourcepos="5:1-8:0">
<li data-sourcepos="5:1-5:185"><strong>Mean/Median Imputation:</strong> Replace missing values with the mean or median of the corresponding feature for all customers (not recommended as it might distort the data distribution).</li>
<li data-sourcepos="6:1-6:195"><strong>Mode Imputation:</strong> Replace missing values with the most frequent value for that feature (can be useful for categorical features but might not be suitable for numerical features like income).</li>
<li data-sourcepos="7:1-8:0"><strong>KNN Imputation:</strong> Utilize kNN itself for imputation!  Find the k-nearest neighbors for a customer with missing values based on available features. Use the corresponding values of those neighbors (income and age) to impute the missing values for that customer.</li>
</ol><p data-sourcepos="9:1-9:32"><strong>kNN Algorithm Modifications:</strong></p><ol data-sourcepos="11:1-15:0">
<li data-sourcepos="11:1-13:149"><strong>Distance Metrics for Missing Values:</strong> Employ distance metrics that can handle missing values, such as:
<ul data-sourcepos="12:5-13:149">
<li data-sourcepos="12:5-12:127"><strong>Manhattan Distance:</strong> Less sensitive to outliers compared to Euclidean distance and can be effective with missing data.</li>
<li data-sourcepos="13:5-13:149"><strong>Minkowski Distance:</strong> A generalization of Manhattan and Euclidean distance, where p can be adjusted to control sensitivity to missing values.</li>
</ul>
</li>
<li data-sourcepos="14:1-15:0"><strong>Weighted kNN:</strong> Assign lower weights to features with missing values during distance calculations. This reduces the influence of missing features on finding the nearest neighbors.</li>
</ol><p data-sourcepos="16:1-16:32"><strong>Choosing the Right Approach:</strong></p><ul data-sourcepos="18:1-20:0">
<li data-sourcepos="18:1-18:130">The best approach depends on the amount of missing data, its distribution across features, and the overall data characteristics.</li>
<li data-sourcepos="19:1-20:0">KNN imputation can be computationally expensive, especially for large datasets. Consider the trade-off between imputation accuracy and processing time.</li>
</ul><p data-sourcepos="21:1-21:25">Here's an additional tip:</p><ul data-sourcepos="23:1-25:0">
<li data-sourcepos="23:1-25:0"><strong>Impute Missing Values Before Applying kNN:</strong>  It's generally recommended to impute missing values before feeding the data into the kNN model for classification. This ensures consistent data representation for all customers during neighbor search and prediction.</li>
</ul><p data-sourcepos="26:1-26:258">By using these strategies, you can address missing values in your customer data and leverage kNN for effective customer segmentation. You can experiment with different imputation techniques and distance metrics to find the best fit for your specific dataset.</p></div>

<h2>Demo for this: 
Weighted kNN: Assign lower weights to features with missing values during distance calculations. This reduces the influence of missing features on finding the nearest neighbors.</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:115">Here's a basic code example demonstrating weighted kNN for distance calculation with missing values (using Python):</p><code-block _nghost-ng-c2652366121="" ng-version="0.0.0-PLACEHOLDER"><!----><!----><!----><!----><div _ngcontent-ng-c2652366121="" class="code-block ng-star-inserted"><div _ngcontent-ng-c2652366121="" class="code-block-decoration header gmat-subtitle-1 ng-star-inserted"><span _ngcontent-ng-c2652366121="">Python</span></div><!----><div _ngcontent-ng-c2652366121="" class="code-block-internal-container"><pre _ngcontent-ng-c2652366121=""><code _ngcontent-ng-c2652366121="" role="text" data-test-id="code-content" class="code-container" data-sourcepos="3:1-62:0"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.utils.extmath <span class="hljs-keyword">import</span> weighted_mode
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">weighted_knn_distance</span>(<span class="hljs-params">x1, x2, weights</span>):</span>
    <span class="hljs-string">"""
    Calculates weighted distance between two data points considering missing values.

    Args:
        x1: First data point (array-like).
        x2: Second data point (array-like).
        weights: Array of weights corresponding to features in x1 and x2.

    Returns:
        Weighted distance between x1 and x2.
    """</span>
    <span class="hljs-comment"># Handle missing values (represented by np.nan) by assigning 0 weight</span>
    weights = np.where(np.isnan(x1), <span class="hljs-number">0</span>, weights)
    weights = np.where(np.isnan(x2), <span class="hljs-number">0</span>, weights)
    <span class="hljs-comment"># Calculate weighted squared difference</span>
    distance_sq = np.<span class="hljs-built_in">sum</span>(weights * np.square(x1 - x2))
    <span class="hljs-keyword">return</span> np.sqrt(distance_sq)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedKNN</span>(<span class="hljs-params">KNeighborsClassifier</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n_neighbors, metric=<span class="hljs-string">'euclidean'</span></span>):</span>
    <span class="hljs-built_in">super</span>().__init__(n_neighbors=n_neighbors, metric=metric)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_metric</span>(<span class="hljs-params">self, X, Y, return_distance=<span class="hljs-literal">True</span></span>):</span>
    <span class="hljs-string">"""
    Overrides the distance metric calculation to use weighted_knn_distance.
    """</span>
    distances = np.zeros((X.shape[<span class="hljs-number">0</span>], Y.shape[<span class="hljs-number">0</span>]))
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">0</span>]):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.shape[<span class="hljs-number">0</span>]):
        <span class="hljs-comment"># Calculate weights based on missing values (1 for non-missing, 0 for missing)</span>
        weights = np.ones_like(X[i])
        weights[np.isnan(X[i])] = <span class="hljs-number">0</span>
        weights_j = np.ones_like(Y[j])
        weights_j[np.isnan(Y[j])] = <span class="hljs-number">0</span>
        distances[i, j] = weighted_knn_distance(X[i], Y[j], weights * weights_j)
    <span class="hljs-keyword">return</span> distances


<span class="hljs-comment"># Example usage</span>
X_train = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [np.nan, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])
X_test = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, np.nan]])
y_train = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])

<span class="hljs-comment"># Create and fit the weighted kNN model</span>
knn_weighted = WeightedKNN(n_neighbors=<span class="hljs-number">2</span>)
knn_weighted.fit(X_train, y_train)

<span class="hljs-comment"># Predict class label for test data point</span>
y_pred = knn_weighted.predict(X_test)
print(y_pred)  <span class="hljs-comment"># Output: [1] (assuming appropriate distance metric)</span>

</code></pre><!----><!----><!----></div><div _ngcontent-ng-c2652366121="" hide-from-message-actions="" class="code-block-decoration footer gmat-overline hide-from-message-actions ng-star-inserted"><div _ngcontent-ng-c2652366121=""><span _ngcontent-ng-c2652366121=""> Use code <a _ngcontent-ng-c2652366121="" href="/faq#coding" target="_blank" rel="noopener noreferrer" aria-label="with caution (opens in a new window)" class="disclaimer-suffix">with caution.</a></span></div><div _ngcontent-ng-c2652366121="" class="buttons"><!----><!----><!----><!----><!----><!----><button _ngcontent-ng-c2652366121="" aria-label="Copy code" mat-icon-button="" mattooltip="Copy code" class="mat-mdc-tooltip-trigger copy-button mdc-icon-button mat-mdc-icon-button gmat-mdc-button-with-prefix mat-unthemed mat-mdc-button-base gmat-mdc-button" mat-ripple-loader-uninitialized="" mat-ripple-loader-class-name="mat-mdc-button-ripple" mat-ripple-loader-centered="" jslog="179062;track:generic_click,impression;BardVeMetadataKey:[[&quot;r_7c9b06995f12e313&quot;,&quot;c_e48fbd92ef0bdbc5&quot;,null,&quot;rc_c7022af055324724&quot;,null,null,&quot;en&quot;,null,1,null,null,1,0]];mutable:true"><span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span><mat-icon _ngcontent-ng-c2652366121="" role="img" class="mat-icon notranslate google-symbols mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">content_copy</mat-icon><span class="mat-mdc-focus-indicator"></span><span class="mat-mdc-button-touch-target"></span></button><!----></div></div><!----></div><!----></code-block><p data-sourcepos="64:1-64:16"><strong>Explanation:</strong></p><ol data-sourcepos="66:1-71:0">
<li data-sourcepos="66:1-66:143">This code defines a custom <code>weighted_knn_distance</code> function that calculates the distance between two data points considering missing values.</li>
<li data-sourcepos="67:1-67:194">The function assigns a weight of 0 to features with missing values (represented by <code>np.nan</code>) in both data points. This effectively reduces their influence on the overall distance calculation.</li>
<li data-sourcepos="68:1-68:122">A custom <code>WeightedKNN</code> class inherits from the <code>KNeighborsClassifier</code> class and overrides the <code>distance_metric</code> method.</li>
<li data-sourcepos="69:1-69:131">The overridden <code>distance_metric</code> utilizes the <code>weighted_knn_distance</code> function for distance calculations during neighbor search.</li>
<li data-sourcepos="70:1-71:0">The example usage demonstrates fitting a kNN model with this custom distance metric and predicting a class label for a data point with a missing value.</li>
</ol><p data-sourcepos="72:1-72:9"><strong>Note:</strong></p><ul data-sourcepos="74:1-75:167">
<li data-sourcepos="74:1-74:176">This example uses a simple approach for handling missing values. Real-world applications might involve more sophisticated imputation techniques before applying weighted kNN.</li>
<li data-sourcepos="75:1-75:167">The choice of distance metric (<code>metric</code> parameter in <code>KNeighborsClassifier</code>) can also be adjusted based on the data and the specific way missing values are handled.</li>
</ul></div>

<h2>Solve this:
High-Dimensional Text Data Clustering: You want to cluster news articles by topic using kNN. Text data can be high-dimensional due to a large vocabulary. What pre-processing techniques can you apply to make kNN work efficiently for text clustering? How can you choose an appropriate distance metric for this scenario?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><h2 data-sourcepos="1:1-1:50">High-Dimensional Text Data Clustering with kNN</h2><p data-sourcepos="3:1-3:106">Here's how you can make kNN work efficiently for clustering high-dimensional text data like news articles:</p><p data-sourcepos="5:1-5:30"><strong>Pre-processing Techniques:</strong></p><ol data-sourcepos="7:1-12:0">
<li data-sourcepos="7:1-7:211"><strong>Text Cleaning:</strong> Remove stop words (common words like "the", "a", "an") and punctuation marks. These words don't contribute much to the meaning of the document and can increase dimensionality unnecessarily.</li>
<li data-sourcepos="8:1-8:166"><strong>Stemming or Lemmatization:</strong> Reduce words to their root form (e.g., "running" becomes "run"). This helps group similar words together and reduces dimensionality.</li>
<li data-sourcepos="9:1-12:0"><strong>Feature Engineering:</strong>
<ul data-sourcepos="10:5-12:0">
<li data-sourcepos="10:5-10:368"><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong> This technique assigns weights to words based on their frequency in a document and rarity across the entire corpus. Words that are frequent in a document but rare overall are more informative for topic identification. This reduces the impact of very common words and emphasizes words specific to the topic.</li>
<li data-sourcepos="11:5-12:0"><strong>N-grams:</strong> Create features by considering sequences of words (bigrams, trigrams). This can capture phrases and short expressions that might be indicative of specific topics. However, be cautious of the curse of dimensionality with higher n-grams.</li>
</ul>
</li>
</ol><p data-sourcepos="13:1-13:44"><strong>Choosing an Appropriate Distance Metric:</strong></p><p data-sourcepos="15:1-15:141">Since traditional distance metrics like Euclidean distance might not be suitable for high-dimensional text data, consider these alternatives:</p><ol data-sourcepos="17:1-20:0">
<li data-sourcepos="17:1-17:288"><strong>Cosine Similarity:</strong> This metric measures the angle between two document vectors. Documents with similar topics will have high cosine similarity. It's less sensitive to the magnitude of the vectors and focuses on the directional relationship, which is more relevant for textual data.</li>
<li data-sourcepos="18:1-18:282"><strong>Jaccard Similarity:</strong> This metric calculates the ratio of the number of shared words between two documents to the total number of unique words in both documents. It's a good choice when the order of words is not important and captures the presence or absence of specific terms.</li>
<li data-sourcepos="19:1-20:0"><strong>Levenshtein Distance:</strong> This metric calculates the minimum number of edits (insertions, deletions, substitutions) required to transform one document into another. It's useful when dealing with potential typos or slightly different phrasings related to the same topic.</li>
</ol><p data-sourcepos="21:1-21:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="23:1-25:0">
<li data-sourcepos="23:1-23:279"><strong>Dimensionality Reduction Techniques:</strong> Techniques like Principal Component Analysis (PCA) can further reduce the dimensionality of the data while preserving most of the relevant information. This can significantly improve the efficiency of kNN for high-dimensional text data.</li>
<li data-sourcepos="24:1-25:0"><strong>Choice of <code>k</code>:</strong> Experiment with different values of <code>k</code> (number of nearest neighbors) to find the optimal setting for your specific dataset and desired cluster granularity.</li>
</ul><p data-sourcepos="26:1-26:154">By applying these techniques, you can make kNN a viable approach for clustering news articles by topic even when dealing with high-dimensional text data.</p></div>

<h2>Solve this:
Combining kNN with Feature Engineering: You're building a kNN model to predict stock prices. While raw historical prices can be used as features, could feature engineering techniques like calculating moving averages or volatility indicators improve the performance of kNN for stock price prediction? Why or why not?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><h2 data-sourcepos="1:1-1:68">Combining kNN with Feature Engineering for Stock Price Prediction</h2><p data-sourcepos="3:1-3:182">Yes, feature engineering techniques like calculating moving averages or volatility indicators can significantly improve the performance of kNN for stock price prediction. Here's why:</p><p data-sourcepos="5:1-5:30"><strong>Limitations of Raw Prices:</strong></p><ul data-sourcepos="7:1-9:0">
<li data-sourcepos="7:1-7:307"><strong>High Dimensionality:</strong> Using raw historical closing prices for a long period results in a high-dimensional feature space. This can be inefficient for kNN, making it computationally expensive and potentially leading to the "curse of dimensionality" where distances between data points become meaningless.</li>
<li data-sourcepos="8:1-9:0"><strong>Limited Information:</strong> Raw closing prices only capture a single aspect of the market at a specific point. They don't directly reflect underlying trends, momentum, or volatility.</li>
</ul><p data-sourcepos="10:1-10:36"><strong>Benefits of Feature Engineering:</strong></p><ul data-sourcepos="12:1-14:0">
<li data-sourcepos="12:1-12:244"><strong>Reduced Dimensionality:</strong> Calculating technical indicators like moving averages or volatility indicators from raw prices creates a more concise feature set. This reduces the computational cost of kNN and potentially improves its efficiency.</li>
<li data-sourcepos="13:1-14:0"><strong>Extracted Insights:</strong> Technical indicators summarize past price movements and market sentiment. Features like moving averages capture trends, while volatility indicators like Bollinger Bands or Relative Strength Index (RSI) reflect market sentiment and potential turning points. By incorporating these features, kNN can learn from historical patterns and make more informed predictions.</li>
</ul><p data-sourcepos="15:1-15:102">Here are some specific examples of feature engineering techniques for stock price prediction with kNN:</p><ul data-sourcepos="17:1-21:0">
<li data-sourcepos="17:1-17:152"><strong>Moving Averages:</strong> Simple Moving Average (SMA), Exponential Moving Average (EMA), etc., can indicate trends and potential support/resistance levels.</li>
<li data-sourcepos="18:1-18:143"><strong>Volatility Indicators:</strong> Bollinger Bands, RSI, Average True Range (ATR) provide insights into market volatility and potential price swings.</li>
<li data-sourcepos="19:1-19:160"><strong>Momentum Indicators:</strong> Moving Average Convergence Divergence (MACD), Stochastic Oscillator, etc., can capture the strength and direction of price movements.</li>
<li data-sourcepos="20:1-21:0"><strong>Volume-based Features:</strong> Trading volume alongside price data can offer additional insights into market sentiment and potential breakouts.</li>
</ul><p data-sourcepos="22:1-22:19"><strong>Overall Impact:</strong></p><p data-sourcepos="24:1-24:290">By incorporating these features, you provide kNN with a richer set of information that goes beyond just historical closing prices. This allows the model to identify patterns and relationships between the features and future price movements, potentially leading to more accurate predictions.</p><p data-sourcepos="26:1-26:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="28:1-30:185">
<li data-sourcepos="28:1-28:191">Not all features might be equally informative. Experiment with different combinations of technical indicators to find the optimal feature set for your specific dataset and prediction goals.</li>
<li data-sourcepos="29:1-29:167">Feature engineering is not a magic bullet. The quality and relevance of the chosen features ultimately determine the effectiveness of kNN for stock price prediction.</li>
<li data-sourcepos="30:1-30:185">Remember that stock prices are inherently unpredictable, and kNN predictions should be used with caution, ideally combined with other analysis techniques for informed decision-making.</li>
</ul></div>

<h2>Solve this:
kNN for Anomaly Detection: Anomaly detection involves identifying data points that deviate significantly from the norm. How can you adapt kNN to identify anomalies in sensor data streams, considering factors like real-time processing and flagging potential outliers effectively?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><h2 data-sourcepos="1:1-1:70">Adapting kNN for Anomaly Detection in Real-Time Sensor Data Streams</h2><p data-sourcepos="3:1-3:84">Here's how you can adapt kNN for anomaly detection in real-time sensor data streams:</p><p data-sourcepos="5:1-5:40"><strong>Efficiency for Real-Time Processing:</strong></p><ul data-sourcepos="7:1-10:0">
<li data-sourcepos="7:1-7:222"><strong>Limited Neighborhood Search:</strong> Utilize techniques like ball trees or kd-trees for efficient neighbor identification. These data structures enable faster retrieval of the k-nearest neighbors for a new sensor data point.</li>
<li data-sourcepos="8:1-8:235"><strong>Approximate Nearest Neighbors (ANN):</strong> Consider using approximate nearest neighbor algorithms to find "good enough" neighbors instead of the exact ones. This can significantly reduce processing time for real-time anomaly detection.</li>
<li data-sourcepos="9:1-10:0"><strong>Reduce Feature Dimensionality:</strong> Analyze the sensor data and identify the most relevant features for anomaly detection. Using a smaller feature set speeds up kNN calculations. Feature selection techniques like LASSO regression or chi-square tests can be helpful.</li>
</ul><p data-sourcepos="11:1-11:26"><strong>Identifying Anomalies:</strong></p><ul data-sourcepos="13:1-15:0">
<li data-sourcepos="13:1-13:306"><strong>Distance Thresholding:</strong> Define a distance threshold based on the distribution of nearest neighbor distances for normal data points. Sensor readings exceeding this threshold are considered potential anomalies. This threshold can be dynamically adjusted based on historical data or statistical analysis.</li>
<li data-sourcepos="14:1-15:0"><strong>Density-Based Outlier Detection (DBSCAN):</strong> Implement DBSCAN alongside kNN. DBSCAN can identify clusters of similar sensor readings and mark data points far away from any dense clusters as potential anomalies. This approach complements kNN by considering the overall data density.</li>
</ul><p data-sourcepos="16:1-16:44"><strong>Flagging Potential Outliers Effectively:</strong></p><ul data-sourcepos="18:1-20:0">
<li data-sourcepos="18:1-18:252"><strong>Confidence Scores:</strong> Assign confidence scores to anomaly detections based on the distance to the nearest neighbors or the degree of deviation from the distance threshold. This allows prioritizing high-confidence anomalies for further investigation.</li>
<li data-sourcepos="19:1-20:0"><strong>Time-Series Analysis:</strong> Analyze the temporal behavior of potential anomalies. Sudden spikes or changes compared to past readings can strengthen the case for an anomaly.</li>
</ul><p data-sourcepos="21:1-21:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="23:1-25:0">
<li data-sourcepos="23:1-23:218"><strong>Concept Drift:</strong> Since sensor data patterns might change over time, consider techniques like online kNN variants or periodic retraining to adapt the model to evolving data distributions and potential concept drift.</li>
<li data-sourcepos="24:1-25:0"><strong>Alerting System:</strong> Design an alerting system based on confidence scores and temporal analysis. This system can trigger notifications for high-confidence anomalies requiring immediate attention.</li>
</ul><p data-sourcepos="26:1-26:31"><strong>Here's an example approach:</strong></p><ol data-sourcepos="28:1-36:0">
<li data-sourcepos="28:1-28:57">Pre-process sensor data and extract relevant features.</li>
<li data-sourcepos="29:1-29:55">Maintain a sliding window of recent sensor readings.</li>
<li data-sourcepos="30:1-34:75">For each new data point:
<ul data-sourcepos="31:5-34:75">
<li data-sourcepos="31:5-31:72">Use a ball tree to find the k-nearest neighbors within the window.</li>
<li data-sourcepos="32:5-32:46">Calculate the distance to the neighbors.</li>
<li data-sourcepos="33:5-33:101">Compare the distance to a dynamically adjusted threshold or analyze local density using DBSCAN.</li>
<li data-sourcepos="34:5-34:75">Assign a confidence score based on the deviation or density analysis.</li>
</ul>
</li>
<li data-sourcepos="35:1-36:0">Trigger alerts for high-confidence anomalies with additional analysis of their temporal behavior.</li>
</ol><p data-sourcepos="37:1-37:209">By incorporating these strategies, you can leverage kNN for real-time anomaly detection in sensor data streams, effectively identifying and flagging potential outliers while maintaining processing efficiency.</p></div>

<h2>Some potential areas to explore for kNN?</h2>

<div _ngcontent-ng-c278564816="" class="markdown markdown-main-panel" dir="ltr" style="--animation-duration: 600ms; --fade-animation-function: linear;"><p data-sourcepos="1:1-1:126">Here are some potential areas we could explore:</p><p data-sourcepos="3:1-3:28"><strong>Advanced kNN Techniques:</strong></p><ul data-sourcepos="5:1-8:0">
<li data-sourcepos="5:1-5:311"><strong>Locality Sensitive Hashing (LSH):</strong> This technique can significantly accelerate neighbor searches in high-dimensional data by probabilistically hashing similar data points close together. It's particularly useful for large datasets where traditional distance-based searches become computationally expensive.</li>
<li data-sourcepos="6:1-6:228"><strong>Cover Trees:</strong> These data structures provide efficient nearest neighbor search guarantees, especially in low-dimensional datasets. They can be a good alternative to ball trees or kd-trees depending on your specific scenario.</li>
<li data-sourcepos="7:1-8:0"><strong>Weighted kNN:</strong> As we discussed previously, weighted kNN assigns different weights to features during distance calculations. You could explore more sophisticated weighting schemes based on feature importance or domain knowledge to further improve kNN performance.</li>
</ul><p data-sourcepos="9:1-9:46"><strong>Applications of kNN Beyond Classification:</strong></p><ul data-sourcepos="11:1-14:0">
<li data-sourcepos="11:1-11:289"><strong>Regression:</strong> kNN can be adapted for regression tasks by using the average or weighted average of the target values of the k-nearest neighbors as the predicted value for a new data point. This approach can be useful for tasks like predicting continuous sensor readings or stock prices.</li>
<li data-sourcepos="12:1-12:252"><strong>Recommender Systems:</strong> kNN can be used to create collaborative filtering systems. By finding users with similar historical behavior (based on features like purchase history or ratings), you can recommend items that those similar users have enjoyed.</li>
<li data-sourcepos="13:1-14:0"><strong>Anomaly Detection (Advanced):</strong> We discussed some basic kNN adaptations for anomaly detection. You could delve deeper into techniques like Isolation Forests or Local Outlier Factor (LOF) that are specifically designed for identifying anomalies in data.</li>
</ul><p data-sourcepos="15:1-15:36"><strong>Choosing the Right kNN Approach:</strong></p><p data-sourcepos="17:1-17:66">Selecting the most suitable kNN variation depends on factors like:</p><ul data-sourcepos="19:1-23:0">
<li data-sourcepos="19:1-19:100"><strong>Dataset characteristics:</strong> Size, dimensionality, data distribution (e.g., presence of outliers).</li>
<li data-sourcepos="20:1-20:66"><strong>Task type:</strong> Classification, regression, or anomaly detection.</li>
<li data-sourcepos="21:1-21:102"><strong>Computational constraints:</strong> Real-time processing requirements or limitations in processing power.</li>
<li data-sourcepos="22:1-23:0"><strong>Desired accuracy:</strong> Trade-off between accuracy and efficiency.</li>
</ul><p data-sourcepos="24:1-24:157">Experimentation with different kNN approaches, feature engineering techniques, and distance metrics is crucial for optimizing kNN for your specific use case.</p><p data-sourcepos="26:1-26:30"><strong>Additional Considerations:</strong></p><ul data-sourcepos="28:1-30:0">
<li data-sourcepos="28:1-28:223"><strong>Interpretability:</strong> While kNN is not inherently as interpretable as some other models (e.g., decision trees), techniques like feature importance analysis can help understand which features kNN relies on for predictions.</li>
<li data-sourcepos="29:1-30:0"><strong>Scalability:</strong> kNN can become computationally expensive for large datasets. Consider techniques like dimensionality reduction or data sampling to improve scalability if needed.</li>
</ul></div>
</pre>

<span style="display: none;">Tags: Technology,Machine Learning,Classification,Interview Preparation,Regression,</span>